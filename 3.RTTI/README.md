# Реализация RTTI

*Оценка: 4 балла*

## Задача
Чтобы получше понять RTTI в C++, попробуйте сами его реализовать.

Будем использовать C++. Наследование между классами указывается стандартным синтаксисом языка.  
Преобразование от наследника к базовому классу - базовая возможность компилятора и не требует RTTI. Обратное же (downcast) преобразование требует дополнительного программирования.

`DYNAMIC_CAST` будет работать с указателями. Работу со ссылками поддерживать не требуется. Downcast преобразование должно возвращать `nullptr`, если указатель не яляется указанным наследником.

Какой указатель возвращает `DYNAMIC_CAST` если наследование не множественное? Что изменится при множественном наследовании?


### Требуется реализовать

- `TYPEID`:  
  механизм для получения информации о классе (имя, хэш, возможность сравнения);  
- `DYNAMIC_CAST`:  
  механизм для down-cast преобразования указателей;  
- Систему макросов, которая будет включать поддержку RTTI для конкретного класса;  
- Поддержка множественного наследования.

### Рекомендации

Отключите поддержку RTTI при компиляции, чтобы убедиться, что работает именно то, что реализовано вами.

В VisualStudio это делается через настройки проекта
`C/C++ -> Language -> Enable Runtime Time Information: No`

В GCC есть аргумент командной строки `-fno-rtti`

## Оценка
*1 балл* - TYPEID  
*1 балл* - DYNAMIC_CAST без множественного наследования  
*2 балла* - поддержка множественного наследования

