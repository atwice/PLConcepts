# Реализация Future и Promise

*6 баллов*

## Задача

### Требуется

1. Реализовать потокобезопасный `future` и `promise`
	- `promise` и `future` - два аксессора к одному и тому же отложенному результату
	- `promise` - позволяет установить значение в отложенный результат или сигнализировать об ошибке
		- `promise.SetValue` - установить успешный результат в promise
		- `promise.SetException` - установить, что в процессе вычисления отложенного результата произошло исключение
	- `future` - позволяет получить значение отложенного результата
		- `future.Get` - блокирует поток и ожидает возвращение результата
		- `future.TryGet` - не блокирующая попытка получения
		- В случае если promise завершился с ошибкой `future` должна уметь кидать исключения 

2. Реализовать на `future` и `promise` (из пунтка 1) функцию `std::async` http://en.cppreference.com/w/cpp/thread/async  
Поддержать пул из фиксированного количества потоков  
Поддержать запуск функции в следующем виде:
	- Если есть доступные потоки в пуле - запуск задаче в потоке пула
	- Если нет доступных потоков в пуле - запуск задачи синхронно
	- Возможность явно потребовать синхронный запуск

3. Реализовать цепочку future
	Удобный синтаксис:
	- либо `f1.then( f2 ).then( f3 )`
	- либо `f3.callAfter( f2.callAfter( f1 ) )`
	- либо `then( then( f1, f2 ), f3 )`

	Такая конструкция возвращает новый future

	Результат или исключения не должны теряться.  
	Если `f1` выкинул исключение, то `f2` или `f3` не вызываются. Исключение выбрасывается на самый верх и вылетит при `future.Get`  
	Если `f2` выкинул исключение, то результат `f1` не пропал и доступен по `f1.Get`

Каждое требование должно быть проверено соответствующим тестом.

## Оценка
*2 балла* - future+promise  
*2 балла* - std::async  
*2 балла* - then

Если возникают проблемы с пунктом 1, то пункты 2 и 3 можно реализовать на std::future с std::promise, но если пункт 1 выполнен, то должны использоваться свои future и promise.
