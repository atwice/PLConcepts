# Динамический полиморфизм
Создадим свой ООП-язык

*2 балла*

## Задача

Имитировать наследование и виртуальные методы на языке C.

Ваша программа должна содержать 2 структуры. Одна структура - базовая. То есть не имеет “предка”. Другая структура - наследник базовой. (Это должно быть как-то помечено в программе).

У базовой структуры есть несколько “методов”. Структура-наследник переопределяет некоторые “методы” базовой структуры. (Определение методов тоже нужно как-то пометить)

В `main()` создайте 2 “объекта” разных типов: базовый и наследник.  
Продемонстрируйте, что произойдёт при вызове разных методов этих объектов:  
- Метод, определённый в базовом “классе”, но не в классе-наследнике должен быть найден и вызван для наследника.
- Метод, определённый в базовом “классе”, но переопределенный в наследнике, должен учитывать тип объекта, у которого метод вызван.
- Метод, не определённый для данного класса, может компилироваться, но бросать исключение.  
Или не компилироваться - на ваше усмотрение.

### Требования к реализации

- Вы можете использовать компилятор C++;
- Не разрешается использовать ключевое слово virtual;
- Не разрешается использовать готовые системы макросов, например из Qt;
- Реализация методов должна идентифицировать вызов метода, например, выводите на консоль имя метода;
- Достаточно поддержать методы, не имеющие аргументов, не возвращающие значение
`void method();`

### Рекомендации

Для расширения языка рекомендуется использовать макросы.  
Рекомендуется повторить систему таблиц виртуальных функций, которую генерирует C++. 

### Полезные ссылки
https://stackoverflow.com/questions/10507264/how-to-use-macro-argument-as-string-literal
https://en.cppreference.com/w/cpp/preprocessor/replace#.23_and_.23.23_operators

## Оценка
*1 балл* - методы невиртуальные  
или  
*2 балла* - методы виртуальные


## Пример

Это пример для вдохновления. Не обязательно пытаться реализовать именно такие макросы. Возможно, вы захотите использовать классы или лямбда-выражения для кода методов.

```c++
// базовый класс
CLASS( Base )
	int a;
END( Base )

// невиртуальный метод
METHOD( Base, Method1 )
{
	// ...
}

// виртуальный метод
VIRTUAL_METHOD( Base, ToOverride )
{
	// ...
}

// класс-наследник
CLASS_DERIVED( Derived, Base )
	int b;
END_DERIVED( Derived, Base )

// Переопределение виртуального метода
OVERRIDE_METHOD( Derived, ToOverride )
{
	// ...
}

// Невиртуальный метод наследника
METHOD( Derived, OnlyDerived )
{
	// ...
}

void main()
{
	Base base = /* как-то создали базовый класс */
	// работаем как со структурой
	base.a = 0;
	// вызываем методы
	CALL(base, Method1);
	CALL(base, ToOverride);

	Derived derived = /* ... как-то создали наследник */
	// работаем как со структурой
	derived.a = 1;
	derived.b = 2;
	// вызываем методы
	CALL(base, Method1);
	CALL(base, OnlyDerived);
	CALL(base, ToOverride); // должен вызываться переопределенный `Derived::ToOverride`

	// полиморфизм
	Base* asBase = reinterpret_cast<Base*>(&derived);
	CALL(asBase, Method1);
	CALL(asBase, ToOverride); // должен вызываться переопределенный `Derived::ToOverride`
	
	// не компилируется или runtime-ошибка
	CALL(asBase, OnlyDerived);
}
```