# Реализация исключений
*Оценка: 2 + 1 + 1 баллов*

## Задача

Посмотрите: https://en.cppreference.com/w/cpp/utility/program/setjmp

В стандарте C++ оставлена совместимость с языком C по части нелокальных прыжков (goto в другую функцию). Функции `setjmp` и `longjmp` позволяют реализовать любой нелинейный поток управления. Воспользуйтесь этими функциями для реализации собственных исключений.

Создайте систему макросов `TRY`, `CATCH`, `THROW`, которая будет имитировать работу исключений в C++.

Требуется, чтобы по `longjmp` не только менялся контекст, но также очищался стек. То есть удалялись все объекты, созданные на стеке.  
У компилятора есть возможность исчислить все блоки кода, в которых должны быть разрушены автоматические объекты при обработке исключения. У системы макросов такой возможности нет. Поэтому заведем макрос `AUTO_OBJECT`, который используется при созданиина стеке объекта, у которого должен быть вызван деструктор.

Поддержите аварийное завершение программы по повторному исключению во время очистки стека. Пусть при аварийном завершении будет вызвана функция, которую можно указать вызовом `SET_UNEXPECTED_HANDLER`.

### Требования

- Требуется, чтобы исключение могло “пролетать” сквозь несколько вложенных функций;
- Продемонстрируйте в программе, что при вызове THROW вызываются деструкторы локальных объектов на всех стекфреймах вплоть до того, где написаны TRY/CATCH;
- Нельзя использовать готовые системы макросов из каких-либо фреймворков.

### Рекомендации

Отключите поддержку исключений при компиляции, чтобы убедиться, что ваши объекты удаляются именно вашим кодом. Кроме того, setjmp/longjmp плохо взаимодействуют с try/catch.

В VisualStudio это делается через настройки проекта
`C/C++ -> Code Generation -> Enable C++ Exception: No`

В GCC есть аргумент командной строки `-f-no-exceptions`

## Оценка

*2 балла* - Вызов деструкторов при размотке стека  
*1 балл* - Учёт типизации исключений  
*1 балл* - Аварийное завершение программы при повторном исключении

## Пример

```c++
/*
	Заведите класс ошибки для типизации исключений
*/
enum class error {
	io_error,
	math_error,
	…
};

// Функция для обработки ситуации повторного исключения
void crash(error first, error second)
{
}

// Функция бросает исключение
void divide( int num, int denum )
{
	if( denum == 0	) {
		THROW error::math_error;
	}
	return num / denum;
}

// сквозь эту функцию пролетает исключение, вылетающее из `divide`
void auxiliary()
{
	AUTO_OBJECT( CMyClass, auxiliaryObject );
	int z = divide( auxiliaryObject.GetValue(), 0 );
}

void main()
{
	// Регистрация обработчика повторного исключения
	SET_UNEXPECTED_HANDLER(crash);

	TRY {
		// Разместите объект, у которого должен быть вызван деструктор
		AUTO_OBJECT( CMyClass, resourceObject );
		// Эта функция бросит исключение
		b();

	} CATCH( error::io_error ) {
		// ...
		
	} CATCH( error::math_error ) {
		// ...
	}
}


```