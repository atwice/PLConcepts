# Виртуальная машина, построенная на архитектуре фон Неймана

## Задача 1. Интерпретатор байт-кода

*3 балла*

Требуется реализовать виртуальную машину с архитектурой фон Неймана на языке высокого уровня.

### Нужно предоставить:

- Код реализации виртуальной машины;
- Текстовый файл с описанием команд для этой ВМ;
- Программу в байт-кодах, которая выводит на экран “Привет, мир!”.

### Требования:

- ВМ не должна использовать собственной динамической памяти. Все выделения памяти должны происходить в образе программы, загруженной из бинарного файла при старте.
- ВМ запрещается содержать команду “вычислить число Фибоначчи” (см. следующие задачи).
- ВМ запрещается содержать команду “выполнить (eval) программу на другом языке программирования”. То есть система команд ВМ не должна быть сильно сложнее, чем система команд архитектуры x86. Это относится и к числу регистров: их не должно быть слишком много и они не должны быть слишком большими; вполне достаточно использовать некоторое подмножество x86-регистров.




## Задача 2. Ассемблер

*2 балла*

Программировать в байт-кодах неудобно. Удобнее завести систему простой текстовой записи команд.  
У ассемблера очень простой синтаксис. Типичная реализация не требует отдельного лексического парсера.

### Что делает ассемблер

По текстовому файлу:
```
MOV AX, 0
MOV BX, 1
ADD BX, AX
```

Строит бинарный файл:

`0x40 0xFF 0x00 0x00 0xFA 0x50`


### Нужно предоставить:

- Текстовый документ с системой команд ассемблера;
- Ассемблер: реализация программы, которая переводит описанные вами команды в бинарный формат, который способна исполнять машина из [Задачи 1](#Задача-1.-Интерпретатор-байт-кода);
- Пример программы на вашем варианте ассемблера, реализующей вычисление n-го числа Фибоначчи с помощью цикла.

### Требования:

- Программа вычисления числа Фибоначчи перед вычислением должна вывести текстовое сообщение о своём назначении и приглашение ввести число.




## Задача 3. Подпрограммы. Рекурсия

*2 балла*

Подпрограммы - основа декомпозиции в императивном программировании.  
Добавим возможность создавать подпрограммы в нашем ассемблере. Нужно подумать, как передавать аргументы в подпрограмму, как реализовать возврат к точке вызова.  
Заведите в программе сегмент стека. По желанию можно добавить команды push и pop.  
Продумайте соглашение о вызове.

### Необходимо:

- Реализовать в своей ВМ и ассемблере команды call и ret;
- Написать на своём ассемблере пример программы, которая вычисляет число Фибоначчи рекурсивно;

### Требования:

Стек тоже не должен выделяться динамически в ВМ. Используйте для стека память, загруженную вместе с образом программы при старте.



## Задача 4. Переменное число аргументов

*2 + 2\* балла*

Эта задача про “соглашение о вызове”. Как правильно разместить аргументы подпрограммы на стеке, чтобы поддержать переменное число аргументов?

### Необходимо:

- Реализовать на своём ассемблере функцию printf( format, args... ).
	- Функция принимает обязательный аргумент format и произвольное количество дополнительных аргументов args;
	- format - строка, задающая шаблон строки;
	- args подставляются в шаблон строки;
	- Функция выводит на экран строку, в которую подставлены значения аргументов.
- Продемонстрируйте работу вашей функции.

### Требования:

- Формат шаблона придумайте по своему вкусу, но не переусложняйте - ведь реализовывать разбор нужно на ассемблере.
- Шаблон должен быть типизированным, ведь динамически тип переменной узнать нельзя.

Например, шаблон может быть таким:

`printf( “Строка %s, десятичное %i, шестнадцатеричное %x”, “аргумент”, 228, 0xFF )`

Преобразовать аргументы в строку тоже можно на ассемблере в отдельных подпрограммах. Это стоит *+2 балла*. Но можно этого не делать. Тогда можно встроить (типизированные) команды вывода в ВМ.

## \*Задача 5. Дизассемблер

*2 балла*

Обратная задача к ассемблированию - получение исходных кодов по байт-коду программы. 

**Необходимо:**
- Код реализации дизассемблера;
- Пример запуска дизассемблера на своих программах.

**Требования:**

- Дизассемблер должен отличать команды от статически размещенных данных.
